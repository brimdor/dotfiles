# 1Password Session Manager
op_session_manager() {
  local session_dir="$HOME/.op_sessions"
  mkdir -p "$session_dir"
  chmod 700 "$session_dir"

  # Function to retrieve the account alias (user UUID)
  get_account_alias() {
    op account list --format json | jq -r '.[0].user_uuid'
  }

  # Function to sign in and manage the session token
  signin_op() {
    local account_alias="$1"
    local session_file="$2"
    local session_token

    # Check if the session file exists
    if [[ -f "$session_file" ]]; then
      session_token=$(<"$session_file")
      export OP_SESSION_"$account_alias"="$session_token"

      # Verify if the session token is still valid using `op account get`
      if op account get >/dev/null 2>&1; then
        echo "‚úÖ 1Password session for account $account_alias is active."
        return 0
      else
        echo "‚ö†Ô∏è 1Password session for account $account_alias is invalid or expired. Re-authenticating..."
        rm -f "$session_file"
      fi
    fi

    # Proceed to sign in if session is missing or invalid
    echo "üîë Signing in to 1Password account $account_alias..."
    session_token=$(op signin --account "$account_alias" --raw)

    if [[ -z "$session_token" ]]; then
      echo "‚ùå 1Password sign-in failed. Please check your credentials."
      return 1
    fi

    # Save the session token to the session file
    echo "$session_token" > "$session_file"
    chmod 600 "$session_file"

    # Export the session token
    export OP_SESSION_"$account_alias"="$session_token"

    echo "‚úÖ Signed in to 1Password account $account_alias successfully."
  }

  # Retrieve the account alias
  local account_alias
  account_alias=$(get_account_alias)

  if [[ -z "$account_alias" ]]; then
    echo "‚ùå Unable to retrieve 1Password account alias."
    return 1
  fi

  # Define the session file path
  local session_file="$session_dir/session_$account_alias"

  # Handle sign-in with checks within signin_op
  signin_op "$account_alias" "$session_file"
}

# Initialize the 1Password session manager
op_session_manager


#eval $(op signin)
# 1Password
# ---
# EZ cred grabber; Provide itemName/UID for first arg & fieldName of secret/password as the second arg.
creds() {
  cmd="op item get \"$1\" --fields \"$2\""
  eval $cmd
}
# ---
export OPENAI_KEY=`creds "lixusyn5hlqzelvbias36c6vka" "apiKey"`

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="powerlevel10k/powerlevel10k"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
 ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
 COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(
git
zsh-syntax-highlighting
zsh-autosuggestions
web-search
)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

oplogin() {
  eval $(op signin)
}

alias kc='kubectl'

export KUBECONFIG=$HOME/.kube/kubeconfig.yaml
export PATH="$PATH:/home/pkmn-trainer/.local/bin"

#function kc() {
#  KC_COMMAND="$1"
#  kubectl "$KC_COMMAND"
#}

function tf() {
  terraform "$@"
}

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
export PATH=$PATH:/usr/local/bin
export PATH=$PATH:/home/pkmn-trainer/.local/share/gem/ruby/3.0.0/bin
export EDITOR=nvim

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# Cordon Node
function lasso() {
  NODE_NAME="$1"
  kc cordon "$NODE_NAME"
}

# Default drain for Kubernetes
function trench() {
  NODE_NAME="$1"
  kc drain "$NODE_NAME" --ignore-daemonsets --delete-emptydir-data --force --grace-period=10
}

# Created by `pipx` on 2024-02-29 10:44:28
export PATH="$PATH:/home/red/.local/bin"

# Run against all nodes
function roan () {
    # Check if a command was provided
    if [ -z "$1" ]; then
        echo "Usage: roan <command>"
        return 1
    fi

    NODE_COMMAND="$1"
    # Fetch all node IPs using kubectl and execute the command on each
    for ip in $(kubectl get nodes -o wide --no-headers | awk '{print $6}')
    do
        echo "Executing on $ip..."
        ssh root@$ip "$NODE_COMMAND"
    done
}

alias ynv='yq -o json | jnv'

# Set context in kubectl (namespace set)
alias ksn='kubectl config set-context --current --namespace'

function checkplexstreams() {
  plexstreams=$(curl -L -s 'http://tautulli.lajas.tech/api/v2?apikey='$(creds 'mbvi72of2jyoxcg6pll662dpwe' 'apiKey')'&cmd=get_activity' | jq -r '.response.data.stream_count')
  if [ "$plexstreams" -gt 0 ]; then
    if [ "$plexstreams" -eq 1 ]; then
      echo "There is $plexstreams stream currently running."
    else
      echo "There are $plexstreams streams currently running."
    fi
  else
    echo "There are no streams currently running."
  fi
}

function create_repo_and_setup_git() {
    if [ "$#" -ne 3 ]; then
        echo "Usage: create_repo_and_setup_git <repo_name> <description> <private (true/false)>"
        return 1
    fi

    repo_name=$1
    description=$2
    private=$3

    # Get the URL from 1Password
    repo_url=$(op item get dnpf6mebgjootuflw5hb2jeqbe --format json | jq -r '.urls[].href')

    # Perform the API call to create the repo and capture the output
    response=$(curl -s -X POST -H "Content-Type: application/json" \
        -u $(creds 'dnpf6mebgjootuflw5hb2jeqbe' 'user_name'):$(creds 'dnpf6mebgjootuflw5hb2jeqbe' 'password') \
        -d "{\"name\": \"$repo_name\", \"description\": \"$description\", \"private\": $private}" \
        $repo_url/api/v1/user/repos)

    # Check if the response contains the repo name to confirm success
    if echo "$response" | grep -q "\"name\":\"$repo_name\""; then
        echo "Success! Repository '$repo_name' created."

        # Get the git username
        git_user=$(creds 'dnpf6mebgjootuflw5hb2jeqbe' 'user_name')

        # Switch to home directory
        cd ~/$git_user || exit

        # Create a folder for the repo
        mkdir "$repo_name"
        cd "$repo_name" || exit

        # Initialize Git repository and push the first commit
        touch README.md
        git init
        git checkout -b main
        git add README.md
        git commit -m "first commit"

        # Extract the repository URL without the 'https://' and trailing '/'
        clean_repo_url=$(echo "$repo_url" | sed -e 's#https://##' -e 's#/$##')

        # Add the remote and push the first commit
        git remote add origin "git@$clean_repo_url:$git_user/$repo_name.git"
        git push -u origin main

        echo "Local Git repository initialized and first commit pushed to remote!"
    else
        echo "Error: Failed to create repository."
        echo "$response"  # You can comment this out if you want to fully hide the response in case of failure.
    fi
}
function rip_of () {
  kubectl -n vault exec -it deployments/vault-jtr -- ofscraper -u $1 -a download -o all -t all
}
eval "$(zoxide init zsh)"
eval "$(gh copilot alias -- zsh)"
